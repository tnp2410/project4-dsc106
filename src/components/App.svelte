<h1>Gotta Catch 'Em All!</h1>
<div class="author-line">
  <h1>by Tracy Pham and Jenna Canicosa</h1>
</div>

<main style="margin-bottom: 100px;">
  <h1 style="font-size: 1.2em; margin-top: 20px;">Welcome to the Pokémon universe!</h1>
  <div style="border: none; background-color: #3c5aa6; border-radius: 10px; text-align: center; padding: 20px;">
  <p style="margin: 0;">
  Welcome, aspiring Pokémon trainers, to an exciting training course designed to unlock the mysteries of Pokémon strength! As you step into the vibrant world of Pokémon, get ready to embark on an exhilarating journey filled with discovery and adventure.

Throughout this course, we will delve deep into the captivating realm of Pokémon, where we'll uncover the secrets behind what truly makes a Pokémon powerful. Our mission is to equip you with the knowledge and skills necessary to become a formidable Pokémon trainer. <br><br>

Whether you're a seasoned enthusiast of the mainline games, a dedicated Pokémon GO player, or simply curious about the intricacies of Pokémon combat mechanics, this course is tailored just for you. Together, we'll explore the fascinating world of Pokémon statistics and strategic thinking.

Join us as we dive into the heart of Pokémon training, where every challenge is an opportunity to grow, and every battle is a chance to showcase your skills. Are you ready to embark on this epic journey and uncover the age-old question: what truly makes a Pokémon strong? Let's begin our adventure!
  </p>
<a href="https://youtu.be/nmdfAOuyyCE" style="color: white;" target="_blank">Watch video tutorial</a>
</div>

  <h1 style="font-size: 1.2em; margin-top: 20px; font-family: 'Press Start 2P', cursive;  text-align: center;text-shadow: -1px -1px 0 #ffcb05, 1px -1px 0 #ffcb05, -1px 1px 0 #ffcb05, 1px 1px 0 yellow; color: #3c5aa6; "> Lesson 1: Understanding the Impact of Weight on Stats!</h1>
  <p style = "border: none; background-color: #3c5aa6; border-radius:10px;">
  As trainers eager to enhance their knowledge, let's tackle a common question: Does a Pokémon's weight directly correlate with its strength? To explore this, we'll dive into data analysis, comparing the average stats of Pokémon weighing over 65 kg with those of lighter ones. <br><br>
  In our quest for clarity, we must first address the nuances of Pokémon weight. With the median weight at 27 kg and the average at 61 kg, heavier Pokémon skew the overall statistics. To ensure accuracy, we've set a weight threshold of 65 kg, representing the 75th percentile of Pokémon weights, to identify "heavy" Pokémon.  <br><br> 
    </p>
  <div id="bar-chart-container"></div>
  <p style = "border: none; background-color: #3c5aa6; border-radius:10px;">
Upon analyzing the data, we find that in terms of Attack, Defense, Special Attack, and Special Defense, heavier Pokémon tend to exhibit higher average values. This suggests a potential correlation between weight and these offensive and defensive attributes. However, when it comes to Speed, the story takes a different turn. Unlike the other stats, where heavy Pokémon dominate the averages, Speed shows a much more even distribution. This indicates that weight may have less influence on a Pokémon's speed compared to its other attributes. 

This observation underscores the complexity of Pokémon statistics and highlights the importance of considering multiple factors when training and strategizing for battles. As trainers, understanding these nuances allows us to develop more effective and well-rounded battle strategies, ultimately leading to greater success in our Pokémon journey!    
    </p>
<h1 style="font-size: 1.2em; margin-top: 20px; font-family: 'Press Start 2P', cursive;  text-align: center;text-shadow: -1px -1px 0 #ffcb05, 1px -1px 0 #ffcb05, -1px 1px 0 #ffcb05, 1px 1px 0 yellow; color: #3c5aa6; "> Lesson 2: Legendary Pokémon vs. Non-Legendary Pokémon</h1>
  <p style = "border: none; background-color: #3c5aa6; border-radius:10px;">
Legendary Pokémon, revered for their power and mystique, are central to the Pokémon universe. Their enigmatic tales and mythical stature captivate trainers worldwide. As symbols of strength and balance, they embody the essence of Pokémon lore. Our quest is to unravel the mystique surrounding these legendary beings, shedding light on their true power.  <br><br> 
To address the burning inquiry among trainers - Are legendary Pokémon genuinely superior to their non-legendary counterparts? - we embark on an extensive analysis. 
To tackle the inquiry regarding the strength disparity between legendary and non-legendary Pokémon, we initiated our investigation by segregating Pokémon into two distinct groups: legendary and non-legendary. By partitioning the dataset based on their legendary status, we computed the average values for each stat within both categories. 
  <div id="legendary-bar-chart-container"></div>
<p style = "border: none; background-color: #3c5aa6; border-radius:10px;">

The chart unequivocally demonstrates that legendary Pokémon outperform their non-legendary counterparts in all statistics, with a notable emphasis on special attack. This compelling visual evidence adds weight to our findings, dispelling any lingering doubts about the dominance of legendary Pokémon. <br><br>

However, it's crucial to acknowledge that, despite the overall trend favoring legendary Pokémon, this is simply from taking an average so there may still be instances where individual non-legendary Pokémon excel beyond their legendary counterparts. This observation leads us to an intriguing aspect, which we will explore in our next lesson.
 </p>
<h1 style="font-size: 1.2em; margin-top: 20px; font-family: 'Press Start 2P', cursive;  text-align: center;text-shadow: -1px -1px 0 #ffcb05, 1px -1px 0 #ffcb05, -1px 1px 0 #ffcb05, 1px 1px 0 yellow; color: #3c5aa6; "> Lesson 3: Exploring Pokémon through Collapsible Tree </h1>
  <p style = "border: none; background-color: #3c5aa6; border-radius:10px;">
   Pokémon were released in generations based on the main series of the Pokémon video games. Each generation introduced new Pokémon species, regions to explore, gameplay mechanics, and often advances in the Pokémon storyline. There are 18 different elemental types of Pokémon each with their own strengths, weaknesses, and resistances. Knowing the type of each Pokémon can be crucial for success in battles and general strategy. <br><br>
   In this lesson, we'll delve into a captivating visualization that allows trainers to explore different kinds of Pokémon, categorized by generation and type. By navigating through this interactive tool, trainers can deepen their understanding of Pokémon diversity and hone their strategic skills for battles and beyond. Let's embark on this enlightening journey together! <br><br>
  Going back to lesson one about weight:  let's conduct a comparative analysis between the lighter Pokémon Mew and  the heavier Pokémon Rhyhorn. <br>

To locate Mew: click Generation 1 -> psychic -> New Species Pokémon <br>
To locate Rhyhorn, select Generation 1 -> Ground -> Spikes Pokémon <br><br>

Hover over the name of each Pokémon to reveal their respective stats, including attack, defense, speed, HP, special attack, special defense, and weight.

Upon comparison, it becomes evident that despite Rhyhorn's considerable size advantage over Mew, the latter surpasses Rhyhorn in all stats. This observation underscores the notion that size alone does not determine a Pokémon's strength. Mew's superior stats highlight the importance of innate abilities and training in shaping a Pokémon's power. This analysis serves as a valuable reminder to trainers that appearances can be deceiving, and a Pokémon's true strength lies beyond its physical stature.

  </p>
<div id="tree-container"></div>
<p style = "border: none; background-color: #3c5aa6; border-radius:10px;">
Whenever you find yourself in doubt or seeking clarity about a Pokémon's capabilities, don't hesitate to refer back to this chart. It's a valuable tool for understanding the strengths and weaknesses of different Pokémon based on their types, generations, and individual stats. Whether you're strategizing for battles, building your team, or simply satisfying your curiosity about Pokémon, this chart is here to assist you on your journey as a trainer. Happy exploring!
</p>
<h1 style="font-size: 1.2em; margin-top: 20px; font-family: 'Press Start 2P', cursive;  text-align: center;text-shadow: -1px -1px 0 #ffcb05, 1px -1px 0 #ffcb05, -1px 1px 0 #ffcb05, 1px 1px 0 yellow; color: #3c5aa6; "> Final Lesson: Comparison Through Pokémon Radar Chart</h1>
 <p style = "border: none; background-color: #3c5aa6; border-radius:10px;">
Let's dive into the statistics of each Pokémon, examining their attack, defense, HP, special attack, and special defense. While we've already established that factors like legendary status and weight do have a significance on strength, our next step involves delving into the intricate details of each Pokémon's abilities.
    <br>
    To facilitate this analysis, we'll utilize a radar chart, which offers a comprehensive view of a Pokémon's stats across these key attributes. Unlike simplistic metrics such as weight or rarity, this approach allows us to compare the actual combat capabilities of Pokémon relative to one another.
    By utilizing this radar chart, you can delve into the nuances of each Pokémon's abilities and make informed decisions based on your strategic preferences. Whether you value resilience or strength in battle, this tool provides valuable insights to guide your choices.
    <br><br>
If you want to see an interesting comparison, type in “Flareon, Vaporeon”. While they may share similar defense and speed stats, Flareon excels in HP, while Vaporeon boasts superior attack power. This distinction prompts a crucial consideration: whether you prioritize endurance or offensive prowess in your Pokémon selection.
</p>

  <div id="radar-chart-container"></div>
  <p style = "border: none; background-color: #3c5aa6; border-radius:10px;">Have specific Pokémon in mind? Utilize the search bar below to learn more about the Pokémon! Type in a max of 3 Pokemon to explore how they compare. “__, ___, __”  Hover over the radar chart (on the drawn lines) to explore the stats of each pokemon. 
</p>
<div style="text-align: center;">
  <input type="text" id="pokemon-search" placeholder="Search Pokémon">
</div>
<h1 style="font-size: 1.2em; margin-top: 20px; font-family: 'Press Start 2P', cursive;  text-align: center;text-shadow: -1px -1px 0 #ffcb05, 1px -1px 0 #ffcb05, -1px 1px 0 #ffcb05, 1px 1px 0 yellow; color: #3c5aa6; "> <br><br>Guide Completed! </h1>
<p style = "border: none; background-color: #3c5aa6; border-radius:10px;  text-align: center; ">
May your journey as a Pokémon trainer be filled with adventure, discovery, and triumph as you strive to become the ultimate Pokémon master. Gotta catch 'em all!
</p>
</main>

<script>
  import { onMount } from 'svelte';
  import * as d3 from 'd3';

  let svg;

  onMount(() => {
    const width = 1100;
    const marginTop = 30;
    const marginRight = 10;
    const marginBottom = 30;
    const marginLeft = 90;

    // Load data from JSON files
    Promise.all([
      d3.json('pokemon.json'),
      d3.json('tooltipStatsNew.json'),
      d3.json('tooltipStatsNew_copy.json'),
      d3.json('pokemonStats.json'),
      d3.json('weightPokemon.json')
    ]).then(([pokemonData, tooltipData, tooltipCopy, radarData, weightData]) => {
    console.log(radarData);
      const root = d3.hierarchy(pokemonData);
    
      const dx = 35;
      const dy = ((width - marginRight - marginLeft) / (1 + root.height))+10;

      const tree = d3.tree().nodeSize([dx, dy]);
      const diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);

      svg = d3.select('#tree-container')
        .append('svg')
        .attr('width', width)
        .attr('height', dx)
        .attr('viewBox', [-marginLeft, -marginTop, width, dx])
        .attr('style', 'max-width: 110%; height: auto; font: 10px sans-serif; user-select: none;');

      const gLink = svg.append('g')
        .attr('fill', 'none')
        .attr('stroke', '#ffcb05')
        .attr('stroke-opacity', 0.4)
        .attr('stroke-width', 1.8);

      const gNode = svg.append('g')
        .attr('cursor', 'pointer')
        .attr('pointer-events', 'all');

      function update(event, source) {
        const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
        const nodes = root.descendants().reverse();
        const links = root.links();

        // Compute the new tree layout.
        tree(root);

        let left = root;
        let right = root;
        root.eachBefore(node => {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
        });

        const height = right.x - left.x + marginTop + marginBottom;

        const transition = svg.transition()
          .duration(duration)
          .attr('height', height)
          .attr('viewBox', [-marginLeft, left.x - marginTop, width, height])
          .tween('resize', window.ResizeObserver ? null : () => () => svg.dispatch('toggle'));

        // Update the nodes…
        const node = gNode.selectAll('g')
          .data(nodes, d => d.id);

        const nodeEnter = node.enter().append('g')
          .attr('transform', d => `translate(${source.y0},${source.x0})`)
          .attr('fill-opacity', 0)
          .attr('stroke-opacity', 0)
          .on('click', (event, d) => {
            d.children = d.children ? null : d._children;
            update(event, d);
          });

        nodeEnter.append('circle')
          .attr('r', 2.5)
          .attr('fill', d => d._children ? '#FFFF00' : '#FFFF00')
          .attr('stroke-width', 10);

      nodeEnter.append('text')
        .attr('dy', '0.31em')
        .attr('x', d => d._children ? -6 : 6)
        .attr('text-anchor', d => d._children ? 'end' : 'start')
        .text(d => d.data.name)
        .attr('stroke-linejoin', 'round')
        .attr('stroke-width', 4)
        .attr('stroke', 'black')
        .attr('paint-order', 'stroke')
        .attr('fill', 'white')
        .on('mouseover', (event, d) => {
          if (!d.children) {
            const tooltip = d3.select('body').append('div')
              .attr('class', 'tooltip')
              .style('position', 'absolute')
              .style('background-color', '#ffcb05')
              .style('border', 'none')
              .style('border-width', '1px')
              .style('border-radius', '5px')
              .style('padding', '5px')
              .style('color', 'black')
              .html(`
    Stats: <br>
    Attack - ${tooltipData[d.data.name].attack} <br>
    Defense - ${tooltipData[d.data.name].defense} <br>
    Speed - ${tooltipData[d.data.name].speed} <br>
    HP - ${tooltipData[d.data.name].hp} <br>
    Special Attack - ${tooltipData[d.data.name].sp_attack} <br>
    Special Defense - ${tooltipData[d.data.name].sp_defense}<br>
    Weight (kg) - ${tooltipData[d.data.name].weight_kg} <br>
    Legendary - ${tooltipData[d.data.name].is_legendary}
  `);
    
              // Position the tooltip relative to the mouse pointer
              tooltip.style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY + 10) + 'px');
            }
          })
          .on('mouseout', () => {
            // Remove the tooltip when mouse is out
            d3.selectAll('.tooltip').remove();
          });

        const nodeUpdate = node.merge(nodeEnter).transition(transition)
          .attr('transform', d => `translate(${d.y},${d.x})`)
          .attr('fill-opacity', 1)
          .attr('stroke-opacity', 1);

        const nodeExit = node.exit().transition(transition).remove()
          .attr('transform', d => `translate(${source.y},${source.x})`)
          .attr('fill-opacity', 0)
          .attr('stroke-opacity', 0);


        const link = gLink.selectAll('path')
          .data(links, d => d.target.id);

        const linkEnter = link.enter().append('path')
          .attr('d', d => {
            const o = { x: source.x0, y: source.y0 };
            return diagonal({ source: o, target: o });
          });

        link.merge(linkEnter).transition(transition)
          .attr('d', diagonal);

        link.exit().transition(transition).remove()
          .attr('d', d => {
            const o = { x: source.x, y: source.y };
            return diagonal({ source: o, target: o });
          });

        root.eachBefore(d => {
          d.x0 = d.x;
          d.y0 = d.y;
        });
      }

      root.x0 = dy / 2;
      root.y0 = 0;
      root.descendants().forEach((d, i) => {
        d.id = i;
        d._children = d.children;
        if (d.depth && d.data.name.length !== 7) d.children = null;
      });

      update(null, root);
    
      const radarChartContainer = d3.select('#radar-chart-container');

      function drawRadarChart(data) {
    // Extract labels and datasets from the provided data
    const labels = data.labels;
    const datasets = data.datasets;

    // Set up the radar chart dimensions
    const width = 600;
    const height = 800;
    const margin = { top: 400, right: 400, bottom: 2000, left: 400 };
    const chartWidth = 350 - 200;
    const chartHeight = 500 -200;
    const radius = Math.min(chartWidth, chartHeight) / 2;

    // Remove any existing SVG elements within the container
    radarChartContainer.selectAll('svg').remove();

    // Append an SVG element to the radar chart container
    const svg = radarChartContainer
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', `translate(${width / 2 +6}, ${height / 2 +30})`);


  // Define an array of colors for the layers
  const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

  // Create a hexagon background
  const hexagonData = [
    { angle: 0, radius: radius+115},
    { angle: Math.PI / 3, radius: radius+115},
    { angle: (2 * Math.PI) / 3, radius: radius+115 },
    { angle: Math.PI, radius: radius+115 },
    { angle: (4 * Math.PI) / 3, radius: radius+115 },
    { angle: (5 * Math.PI) / 3, radius: radius+115 },
    { angle: 0, radius: radius+115 } // To close the path
  ];

  // Create the hexagon line generator
  const hexagonLine = d3.lineRadial()
    .angle(d => d.angle)
    .radius(d => d.radius);

  // Append the hexagon path
  svg.append('path')
    .datum(hexagonData)
    .attr('class', 'hexagon-background')
    .attr('d', hexagonLine)
    .style('fill', 'none')
    .style('stroke', '#ccc')
    .style('stroke-width', 1)
    .style('stroke-dasharray', '5,5');


  // Create the radial scales for the radar chart
  const rScale = d3.scaleLinear()
    .domain([0, 100]) // Assuming data values range from 0 to 100
    .range([0, radius]);

  // Create the angle scales for the radar chart
  const angleScale = d3.scaleLinear()
    .domain([0, 6])
    .range([0, Math.PI * 2]);

  // Create a radial line generator
  const radarLine = d3.lineRadial()
    .radius(d => rScale(d))
    .angle((d, i) => angleScale(i));

    // Append radar area and line paths for each dataset
  datasets.forEach((dataset, i) => {
    // Add the first data point to the end for a closed path
    dataset.data.push(dataset.data[0]);

    // Append the radar area path
    svg.append('path')
      .datum(dataset.data)
      .attr('class', 'radar-area')
      .attr('d', radarLine)
      .style('fill', colorScale(i));

    // Append the radar line path
    svg.append('path')
      .datum(dataset.data)
      .attr('class', 'radar-line')
      .attr('d', radarLine)
      .style('fill', 'none')
      .style('stroke', colorScale(i))
      .style('stroke-width', 1);
  });

  // Append the labels around the radar chart
  const label = svg.selectAll('.radar-label')
    .data(labels)
    .enter()
    .append('g')
    .attr('class', 'radar-label');

  // Append the label text
  label.append('text')
    .attr('x', (d, i) => (radius + 120) * Math.cos(angleScale(i) - Math.PI / 2)) // Adjusted x position
    .attr('y', (d, i) => (radius + 120) * Math.sin(angleScale(i) - Math.PI / 2)) // Adjusted y position
    .attr('text-anchor', 'middle')
    .text(d => d)
    .style('fill', 'white');
  svg.append('text')
    .attr('class', 'radar-title')
    .attr('x', 0)
    .attr('y', -margin.top + 160)
    .attr('text-anchor', 'middle')
    .text('Radar Chart with Pokémon\'s Stats') // Set your desired title text here
    .style('fill', 'white');
  const gridLines = svg.selectAll('.grid-line')
  .data(d3.range(80, 300, 58)) // Adjust range and step according to your preference
  .enter()
  .append('g')
  .attr('class', 'grid-line');

gridLines.append('path')
  .attr('class', 'grid-line-path')
  .attr('d', d => {
    const gridLineData = [
      { angle: 0, radius: rScale(d) },
      { angle: Math.PI / 3, radius: rScale(d) },
      { angle: (2 * Math.PI) / 3, radius: rScale(d) },
      { angle: Math.PI, radius: rScale(d) },
      { angle: (4 * Math.PI) / 3, radius: rScale(d) },
      { angle: (5 * Math.PI) / 3, radius: rScale(d) },
      { angle: 0, radius: rScale(d) } // To close the path
    ];
    return hexagonLine(gridLineData);
  })
  .style('fill', 'none')
  .style('stroke', '#ccc')
  .style('stroke-width', 1)
  .style('stroke-dasharray', '3,3');

  gridLines.append('text')
  .attr('class', 'grid-line-text')
  .attr('x', d => rScale(d) * Math.cos(Math.PI / 6)) // Adjusted x position
  .attr('y', d => rScale(d) * Math.sin(Math.PI )) // Adjusted y position
  .attr('dy', 5) // Adjust vertical alignment
  .text(d => d) // Display the value of the grid line
  .style('fill', 'yellow')
  .style('font-size', '12px')
  .style('text-anchor', 'middle');
}

function drawFilteredChart(filteredData) {
    // Set up the radar chart dimensions
    const width = 600;
    const height = 800;
    const margin = { top: 400, right: 400, bottom: 2000, left: 400 };
    const chartWidth = 350 - 200;
    const chartHeight = 500 - 200;
    const radius = Math.min(chartWidth, chartHeight) / 2;

    // Remove any existing SVG elements within the container
    radarChartContainer.selectAll('svg').remove();

    // Append an SVG element to the radar chart container
    const svg = radarChartContainer
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', `translate(${width / 2 + 6}, ${height / 2 + 30})`);

    // Define an array of colors for the layers
    const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

    // Create a hexagon background
    const hexagonData = [
        { angle: 0, radius: radius + 115 },
        { angle: Math.PI / 3, radius: radius + 115 },
        { angle: (2 * Math.PI) / 3, radius: radius + 115 },
        { angle: Math.PI, radius: radius + 115 },
        { angle: (4 * Math.PI) / 3, radius: radius + 115 },
        { angle: (5 * Math.PI) / 3, radius: radius + 115 },
        { angle: 0, radius: radius + 115 } // To close the path
    ];

    // Create the hexagon line generator
    const hexagonLine = d3.lineRadial()
        .angle(d => d.angle)
        .radius(d => d.radius);

    // Append the hexagon path
    svg.append('path')
        .datum(hexagonData)
        .attr('class', 'hexagon-background')
        .attr('d', hexagonLine)
        .style('fill', 'none')
        .style('stroke', '#ccc')
        .style('stroke-width', 1)
        .style('stroke-dasharray', '5,5');

    // Create the radial scales for the radar chart
    const rScale = d3.scaleLinear()
        .domain([0, 100]) // Assuming data values range from 0 to 100
        .range([0, radius]);

    // Create the angle scales for the radar chart
    const angleScale = d3.scaleLinear()
        .domain([0, 6])
        .range([0, Math.PI * 2]);

    // Create a radial line generator
    const radarLine = d3.lineRadial()
        .radius(d => rScale(d))
        .angle((d, i) => angleScale(i));

    // Append the radar area path for each filtered dataset
    filteredData.forEach((data, index) => {
        svg.append('path')
            .datum(data.data)
            .attr('class', 'radar-area')
            .attr('d', radarLine)
            .style('fill', 'none')
            .style('stroke', colorScale(index));
    });

    // Append the radar line path for each filtered dataset
    filteredData.forEach((data, index) => {
        svg.append('path')
            .datum(data.data)
            .attr('class', 'radar-line')
            .attr('d', radarLine)
            .style('fill', 'none')
            .style('stroke', colorScale(index)) // Use color for each dataset
            .style('stroke-width', 4);
    });

    // Append the labels around the radar chart
    const label = svg.selectAll('.radar-label')
        .data(["attack", "defense", "speed", "hp", "sp_attack", "sp_defense"])
        .enter()
        .append('g')
        .attr('class', 'radar-label');

    // Append the label text
    label.append('text')
        .attr('x', (d, i) => (radius + 120) * Math.cos(angleScale(i) - Math.PI / 2)) // Adjusted x position
        .attr('y', (d, i) => (radius + 120) * Math.sin(angleScale(i) - Math.PI / 2)) // Adjusted y position
        .attr('text-anchor', 'middle')
        .text(d => d)
        .style('fill', 'white');
    svg.append('text')
        .attr('class', 'radar-title')
        .attr('x', 0)
        .attr('y', -margin.top + 160)
        .attr('text-anchor', 'middle')
        .text('Radar Chart with Pokémon\'s Stats') // Set your desired title text here
        .style('fill', 'white');

    const gridLines = svg.selectAll('.grid-line')
        .data(d3.range(80, 300, 58)) // Adjust range and step according to your preference
        .enter()
        .append('g')
        .attr('class', 'grid-line');

    gridLines.append('path')
        .attr('class', 'grid-line-path')
        .attr('d', d => {
            const gridLineData = [
                { angle: 0, radius: rScale(d) },
                { angle: Math.PI / 3, radius: rScale(d) },
                { angle: (2 * Math.PI) / 3, radius: rScale(d) },
                { angle: Math.PI, radius: rScale(d) },
                { angle: (4 * Math.PI) / 3, radius: rScale(d) },
                { angle: (5 * Math.PI) / 3, radius: rScale(d) },
                { angle: 0, radius: rScale(d) } // To close the path
            ];
            return hexagonLine(gridLineData);
        })
        .style('fill', 'none')
        .style('stroke', '#ccc')
        .style('stroke-width', 1)
        .style('stroke-dasharray', '3,3');

    gridLines.append('text')
        .attr('class', 'grid-line-text')
        .attr('x', d => rScale(d) * Math.cos(Math.PI / 6)) // Adjusted x position
        .attr('y', d => rScale(d) * Math.sin(Math.PI)) // Adjusted y position
        .attr('dy', 5) // Adjust vertical alignment
        .text(d => d) // Display the value of the grid line
        .style('fill', 'yellow')
        .style('font-size', '12px')
        .style('text-anchor', 'middle');
     const tooltip = d3.select('#radar-chart-container')
        .append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0);

    // Add event listeners to radar areas to show/hide tooltip
    svg.selectAll('.radar-line')
        .on('mouseover', function(event, d) {
            const hoveredData = d; // Assuming d contains the stats for the hovered data point
            let tooltipContent = '';

            filteredData.forEach((data, index) => {
                const pokemonName = data.label; // Assuming each dataset contains the Pokémon name
                const stats = data.data; // Assuming each dataset contains the stats
                const color = colorScale(index); // Get the color for the Pokémon
                console.log(stats)
                // Add color swatch and Pokémon name
                tooltipContent += `<div style="display: flex; align-items: center;">`;
                tooltipContent += `<div style="width: 10px; height: 10px; background-color: ${color}; margin-right: 5px;"></div>`;
                tooltipContent += `<strong>${pokemonName}</strong>`;
                tooltipContent += `</div>`;
              
                // Add Pokémon stats
                tooltipContent += `Stats:<br>`;
                tooltipContent += `Attack: ${stats[0]}<br>`;
                tooltipContent += `Defense: ${stats[1]}<br>`;
                tooltipContent += `Speed: ${stats[2]}<br>`;
                tooltipContent += `HP: ${stats[3]}<br>`;
                tooltipContent += `Special Attack: ${stats[4]}<br>`;
                tooltipContent += `Special Defense: ${stats[5]}<br><br>`;
            });

            // Show tooltip
            tooltip.transition()
                .duration(100)
                .style('opacity', .9);
            tooltip.html(tooltipContent)
                .style('left', (event.pageX) + 'px')
                .style('top', (event.pageY) + 'px');
        })
        .on('mouseout', function(d) {
            // Hide tooltip
            tooltip.transition()
                .duration(500)
                .style('opacity', 0);
        });
}
    drawRadarChart(radarData);
const pokemonSearchInput = document.getElementById('pokemon-search');
pokemonSearchInput.addEventListener('input', function () {
  // Get the input value
  const searchValue = pokemonSearchInput.value.toLowerCase();

  // Split the input value by comma to handle two inputs
  const searchValues = searchValue.split(',');

  // Filter radar data based on the input values
  const filteredData = radarData.datasets.filter(dataset =>
    searchValues.some(value => dataset.label.toLowerCase().trim() === value.trim())
  );

  // If no matching Pokémon found, clear the radar chart
  if (filteredData.length === 0) {
    radarChartContainer.selectAll('*').remove();
    return;
  }

  // Update the radar chart with the data of the matching Pokémon
  drawFilteredChart(filteredData);
});

    const heavyPokemon = weightData.filter(pokemon => pokemon.weight_kg > 65);
      const lightPokemon = weightData.filter(pokemon => pokemon.weight_kg <= 65);
      
      // Calculate average stats for heavier and lighter Pokémon
      const averageHeavyStats = calculateAverageStats(heavyPokemon);
      const averageLightStats = calculateAverageStats(lightPokemon);
       drawBarChart(averageHeavyStats, averageLightStats);
       function calculateAverageStats(pokemonData) {
    const stats = ['attack', 'defense', 'speed', 'sp_attack', 'sp_defense'];
    const totalStats = {};
    stats.forEach(stat => {
      totalStats[stat] = pokemonData.reduce((sum, pokemon) => sum + pokemon[stat], 0);
    });
    const count = pokemonData.length;
    const averageStats = {};
    stats.forEach(stat => {
      averageStats[stat] = totalStats[stat] / count;
    });
    return averageStats;
  }
  // Function to draw the bar chart
function drawBarChart(averageHeavyStats, averageLightStats) {
    // Define the data for the bar chart
    const data = [
        { stat: 'Attack', heavy: averageHeavyStats.attack, light: averageLightStats.attack },
        { stat: 'Defense', heavy: averageHeavyStats.defense, light: averageLightStats.defense },
        { stat: 'Speed', heavy: averageHeavyStats.speed, light: averageLightStats.speed },
        { stat: 'Special Attack', heavy: averageHeavyStats.sp_attack, light: averageLightStats.sp_attack },
        { stat: 'Special Defense', heavy: averageHeavyStats.sp_defense, light: averageLightStats.sp_defense },
    ];

    // Set up the dimensions for the bar chart
    const margin = { top: 20, right: 30, bottom: 80, left: 80 }; // Increased bottom margin
    const width = 1000 - margin.left - margin.right; // Adjusted width
    const height = 600 - margin.top - margin.bottom; // Adjusted height

// Append an SVG element to the bar chart container
const svg = d3.select('#bar-chart-container')
    .append('svg')
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);

svg.append('text')
        .attr('x', width / 2)
        .attr('y', 0 - (margin.top / 8))
        .attr('text-anchor', 'middle')
        .style('font-size', '1.5em')
        .style('fill', 'white')
        .text('Average Stats Comparison between Heavy and Light Pokémon'); 

// Define tooltip
const tooltip = d3.select('#bar-chart-container')
    .append('div')
    .style('opacity', 0)
    .attr('class', 'tooltip')
    .style('position', 'absolute')
    .style('border', 'solid')
    .style('border-width', '1px')
    .style('border-radius', '5px')
    .style('padding', '10px');

    // Define scales for x and y axes
    const x = d3.scaleBand()
        .domain(data.map(d => d.stat))
        .range([0, width])
        .padding(0.2);

    const y = d3.scaleLinear()
        .domain([0, d3.max(data, d => Math.max(d.heavy, d.light))])
        .nice()
        .range([height, 0]);

    // Append x axis
    svg.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x))
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x))
        .selectAll('text')
        .style('text-anchor', 'end')
        .attr('dx', '-0.8em')
        .attr('dy', '0.15em')
        .attr('transform', 'rotate(-65)');

    // Append y axis
    svg.append('g')
        .call(d3.axisLeft(y));

    // Append bars for heavier Pokémon
svg.selectAll('.bar-heavy')
    .data(data)
    .enter().append('rect')
    .attr('class', 'bar-heavy')
    .attr('x', d => x(d.stat))
    .attr('y', d => y(d.heavy))
    .attr('width', x.bandwidth() / 2)
    .attr('height', d => height - y(d.heavy))
    .attr('fill', '#c7a008')
    .attr('stroke', 'white')
    // Add tooltip on hover
    .on('mouseover', function(event, d) {
        // Show tooltip on hover
        tooltip.transition()
            .duration(200)
            .style('opacity', .9)
            .style('background-color', '#c7a008')
        tooltip.html(`<strong>${d.stat}:</strong> ${d.heavy}`)
            .style('left', (event.pageX+10) + 'px')
            .style('top', (event.pageY-30) + 'px');
    })
    .on('mouseout', function(d) {
        // Hide tooltip on mouseout
        tooltip.transition()
            .duration(500)
    });

// Append bars for lighter Pokémon
    svg.selectAll('.bar-light')
    .data(data)
    .enter().append('rect')
    .attr('class', 'bar-light')
    .attr('x', d => x(d.stat) + x.bandwidth() / 2)
    .attr('y', d => y(d.light))
    .attr('width', x.bandwidth() / 2)
    .attr('height', d => height - y(d.light))
    .attr('fill', '#E2DC69')
    .attr('stroke', 'white')
    // Add tooltip on hover
    .on('mouseover', function(event, d) {
        // Show tooltip on hover
        tooltip.transition()
            .duration(200)
            .style('background-color', '#B0AB4A')
        tooltip.html(`<strong>${d.stat}:</strong> ${d.light}`)
            .style('left', (event.pageX+10) + 'px')
            .style('top', (event.pageY-30) + 'px');
    })
    .on('mouseout', function(d) {
        // Hide tooltip on mouseout
        tooltip.transition()
            .duration(700)
    });

    // Add legend
    const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', `translate(${width - 50},${margin.top-8})`);

    legend.append('rect')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', 15)
        .attr('height', 15)
        .attr('fill', '#c7a008');

    legend.append('text')
        .attr('x', 20)
        .attr('y', 9)
        .text('Heavier');

    legend.append('rect')
        .attr('x', 0)
        .attr('y', 20)
        .attr('width', 15)
        .attr('height', 15)
        .attr('fill', '#E2DC69');

    legend.append('text')
        .attr('x', 20)
        .attr('y', 29)
        .text('Lighter');
}
// Filter legendary and non-legendary Pokémon
const legendaryPokemon = tooltipCopy.filter(pokemon => pokemon.is_legendary == 1);
const nonLegendaryPokemon = tooltipCopy.filter(pokemon => pokemon.is_legendary == 0);

// Calculate average stats for legendary and non-legendary Pokémon
const averageLegendaryStats = calculateAverageStats(legendaryPokemon);
const averageNonLegendaryStats = calculateAverageStats(nonLegendaryPokemon);

// Draw bar chart for legendary comparison
drawLegendaryBarChart(averageLegendaryStats, averageNonLegendaryStats);

// Function to draw the legendary bar chart
function drawLegendaryBarChart(averageLegendaryStats, averageNonLegendaryStats) {
    // Define data for the bar chart
    const data = [
        { stat: 'Attack', legendary: averageLegendaryStats.attack, nonLegendary: averageNonLegendaryStats.attack },
        { stat: 'Defense', legendary: averageLegendaryStats.defense, nonLegendary: averageNonLegendaryStats.defense },
        { stat: 'Speed', legendary: averageLegendaryStats.speed, nonLegendary: averageNonLegendaryStats.speed },
        { stat: 'Special Attack', legendary: averageLegendaryStats.sp_attack, nonLegendary: averageNonLegendaryStats.sp_attack },
        { stat: 'Special Defense', legendary: averageLegendaryStats.sp_defense, nonLegendary: averageNonLegendaryStats.sp_defense },
    ];

    // Set up dimensions and margins for the chart
     const margin = { top: 20, right: 30, bottom: 80, left: 80 };
    const width = 1000 - margin.left - margin.right;
    const height = 600 - margin.top - margin.bottom;

    // Append an SVG element to the legendary chart container
    const svg = d3.select('#legendary-bar-chart-container')
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      svg.append('text')
        .attr('x', width / 2)
        .attr('y', 0 - (margin.top / 8))
        .attr('text-anchor', 'middle')
        .style('font-size', '1.5em')
        .style('fill', 'white')
        .text('Average Stats Comparison between Heavy and Light Pokémon'); 


    // Define scales for x and y axes
    const x = d3.scaleBand()
        .domain(data.map(d => d.stat))
        .range([0, width])
        .padding(0.2);

    const y = d3.scaleLinear()
        .domain([0, d3.max(data, d => Math.max(d.legendary, d.nonLegendary))])
        .nice()
        .range([height, 0]);
    const legendarytooltip = d3.select('#legendary-bar-chart-container')
    .append('div')
    .style('opacity', 0)
    .attr('class', 'tooltip')
    .style('position', 'absolute')
    .style('border', 'solid')
    .style('border-width', '1px')
    .style('border-radius', '5px')
    .style('padding', '10px');

    // Append x axis
    svg.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x))
        .selectAll('text')
        .style('text-anchor', 'end')
        .attr('dx', '-0.8em')
        .attr('dy', '0.15em')
        .attr('transform', 'rotate(-65)');

    // Append y axis
    svg.append('g')
        .call(d3.axisLeft(y));


    // Append bars for legendary Pokémon
    svg.selectAll('.bar-legendary')
        .data(data)
        .enter().append('rect')
        .attr('class', 'bar-legendary')
        .attr('x', d => x(d.stat))
        .attr('y', d => y(d.legendary))
        .attr('width', x.bandwidth() / 2)
        .attr('height', d => height - y(d.legendary))
        .attr('fill', '#E10A03')
        .attr('stroke', 'white')
    // Add tooltip on hover
    .on('mouseover', function(event, d) {
        legendarytooltip.transition()
            .duration(200)
            .style('opacity', .9)
            .style('background-color', '#E10A03')
        legendarytooltip.html(`<strong>${d.stat}:</strong> ${d.legendary}`)
            .style('left', (event.pageX+10) + 'px')
            .style('top', (event.pageY-30) + 'px');
    })
    .on('mouseout', function(d) {
        // Hide tooltip on mouseout
        legendarytooltip.transition()
            .duration(500)
    });

    // Append bars for non-legendary Pokémon
    svg.selectAll('.bar-non-legendary')
        .data(data)
        .enter().append('rect')
        .attr('class', 'bar-non-legendary')
        .attr('x', d => x(d.stat) + x.bandwidth() / 2)
        .attr('y', d => y(d.nonLegendary))
        .attr('width', x.bandwidth() / 2)
        .attr('height', d => height - y(d.nonLegendary))
        .attr('fill', 'white')
         .attr('stroke', 'red')
    // Add tooltip on hover
        .on('mouseover', function(event, d) {
        // Show tooltip on hover
        legendarytooltip.transition()
            .duration(200)
            .style('background-color', '#656561')
        legendarytooltip.html(`<strong>${d.stat}:</strong> ${d.nonLegendary}`)
            .style('left', (event.pageX+10) + 'px')
            .style('top', (event.pageY-30) + 'px');
    })
    .on('mouseout', function(d) {
        // Hide tooltip on mouseout
        legendarytooltip.transition()
            .duration(700)
    });


    // Add legend
    const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', `translate(${width - 115},${margin.top - 8})`);

    legend.append('rect')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', 15)
        .attr('height', 15)
        .attr('fill', '#E10A03');

    legend.append('text')
        .attr('x', 20)
        .attr('y', 9)
        .text('Legendary');

    legend.append('rect')
        .attr('x', 0)
        .attr('y', 20)
        .attr('width', 15)
        .attr('height', 15)
        .attr('fill', 'white');

    legend.append('text')
        .attr('x', 20)
        .attr('y', 29)
        .text('Non-Legendary');
}
  
    });
  });
</script>


<style>
  /* Write your CSS here */
  p {  
    padding-left: 75px;  
    padding-right: 40px;
  } 

  .tooltip {
    /* Define tooltip styles here */
  }

  .hexagon-background {
    stroke-dasharray: 5,5;
  }

  .grid-line {
    stroke-dasharray: 2,4;
  }


  /* Add borders around the paragraphs */
  p {
    border: 1px solid #ccc; /* Add a border around each paragraph */
    padding: 10px; /* Add padding to give some space between the border and text */
    margin-bottom: 20px; /* Add margin to separate paragraphs */
  }

</style>
